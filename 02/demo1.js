/****
**
**首先了说明一下，代码之间如果耦合（也就是说关联性）太强了，
**很不利于后期的修改，因为你不得一步一步小心翼翼的去剖析你写
**过的代码，然后然后慢慢的改，深怕改了这里影响到其它地方。
**所以我们需要把代码这种耦合性减弱！
***
****/

/***
**
**解耦合之前代码：
**
**假设：a函数里面需要完成两个步骤，第一个步骤算出两数之和
**第二个步骤执行：如果两个数字之和小于100的话，那么去算这个“和”的平方，
**最后结果是返回这个平方值或者两数之和。
**
**说明：实际开发并不是这么简单的逻辑，可能是个复杂的处理流程。
**
***/

function main(num1,num2){
	//1、算出两数之和
	var sum = num1 + num2;
	//2，判断sum是否小于或等于100，如果为true则算平方，否则返回“和”值
	if(sum<=100){
		return sum*sum;
	}else{
		return sum;
	};
};


/**
**上面的代码虽然貌似条理很清晰，但是代码却写的很死，如果稍稍需求一改，就需要
**伤筋断骨的改主函数一大段代码，而且没改一部分，还得考虑有没有牵扯到其它部分。
**究其原因就是代码写得太死，关系太强、不利于扩展。我们需要把代码的这层关系给它
**减弱！
**
**
**思想：把“做什么”跟“为什么要做”的代码逻辑分开
**
**/


/**
** 解耦之后的代码
**/


//定义求和函数

function sum(num1,num2){
	return num1+num2;
};


//定义求平方函数
function square(num){
	return num*num;
};


//定义主函数

function main(num1,num2,maxValue){
	var sum = sum(num1,num2);
	if(sum>maxValue){
		return sum;
	}else{
		return square(sum);
	};
};


/******
**
**由最开始的一个函数现在变成了三个条理清晰的小函数，每个函数之间关系也没有那么多联系，因为每个函数只决定
**做什么运算，并没有越界处理其他逻辑，即便现在那个地方需要改，也不会影响到其他地方！比如，有一天别人对你说
**：“小子，你的求和运算容错太低了吧！”，ok你可以很轻松的去改，不怕影响到其他地方，因为求和运算最终返回一
**个数字而已，于是我做如下改动！
*****/

//改过之后的求和运算
function sum(num1,num2){
	// return ()?num1+num2:0;
	var isNumber = typeof num1 === 'number' && typeof num2 === 'number';
	if(isNumber){
		return num1+num2;
	}else{
		alert("不是数字不能进行运算，结果为0处理哦！");
		return 0;
	};
};



/**
**
**解耦之后的函数，条理更清晰、修改更方便，函数更利于扩展！
**
**/